import sympy as sy
import math
import numpy as np

def Rot(φ):
    rad = math.radians(φ)
    return np.array([[math.cos(rad), -math.sin(rad)], [math.sin(rad), math.cos(rad)]])
#회전변환 행렬

def angle(a, x, y, φ):
    a1 = Rot(-φ) @ np.array([[a[0] - x], [a[1] - y]])
    if math.atan2(a1[1], a1[0]) < 0:
        return math.atan2(a1[1], a1[0]) + 2 * math.pi
    else:
        return math.atan2(a1[1], a1[0])
# 교점 a=(a1,a2)와 중심의 x좌표, y좌표 시계방향으로 기울어진 정도를 넣어
# 기준 축에서 교점까지의 각을 구할 수 있다.

def f(φ, A, B):
    if φ == math.pi / 2 or φ == 3 * math.pi / 2:
        return φ
    else:
        return math.atan(A * math.tan(φ) / B)
    
def esec(φ_1, φ_2, A, B):
    return A * B * (f(φ_2, A, B) - f(φ_1, A, B))/ 2
#중심이 중점인 타원부채꼴 넓이

def tri(mx, my, a):
    return abs(np.linalg.det(np.array([[mx, my, 1], [a[0][0], a[0][1], 1], \
                                       [a[1][0], a[1][1], 1]]))) / 2
#중점, 교점 a, b가 이루는 삼각형의 넓이

def eseg(φ_1, φ_2, A, B, mx, my, a):
    if esec(φ_1, φ_2, A, B) >= A * B * math.pi / 2:
        return esec(φ_1, φ_2, A, B) + tri(mx, my, a)
    else:
        return esec(φ_1, φ_2, A, B) - tri(mx, my, a)
#활꼴 넓이
        

A_1 = float(input("x 반지름 :"))
B_1 = float(input("y 반지름 :"))
mx_1 = float(input("중심 x 좌표 :"))
my_1 = float(input("중심 y 좌표 :"))
φ_1 = float(input("(시계 방향)회전각(°) :"))

x, y = sy.symbols("x y")
#x, y 를 연산 가능한 기호로 선언

a = Rot(φ_1) @ np.array([[x - mx_1], [y-my_1]])
#변환

E1 = sy.Eq(((a[0][0])**2)/(A_1**2) + ((a[1][0])**2)/(B_1**2) - 1 , 0)
E1_deriv = sy.idiff(E1.lhs, y, x)

#타원방정식 a는 행렬꼴, matrix[n+1번째 entry][0 = eq type] 

A_2 = float(input("x 반지름 :"))
B_2 = float(input("y 반지름 :"))
mx_2 = float(input("중심 x 좌표 :"))
my_2 = float(input("중심 y 좌표 :"))
φ_2 = float(input("(시계 방향)회전각(°) :"))

b = Rot(φ_2) @ np.array([[x - mx_2], [y-my_2]])
#변환

E2 = sy.Eq(((b[0][0])**2)/(A_2**2) + ((b[1][0])**2)/(B_2**2) - 1, 0)
#타원방정식

Eq = sy.solve((E1, E2), (x, y))
#두 타원의 교점 (x,y) 꼴 딕셔너리

Eq_real = []
#일반적으로 앞서 x, y의 수 체계를 default 로 설정함
#sympy 모듈에서의 기호의 default 수 체계로 복소수를 취하므로 복소근을 삭제해야함 
#실근 딕셔너리를 따로 만듦

for i in range(len(Eq)):
    if Eq[i][0].is_real:
        Eq_real.append(Eq[i])
    else:
        pass
#전체 근 딕셔너리에서 x값이 실수이면 실근 딕셔너리에 추가

#Eq_real, len(Eq_real)
#이로써 실근의 좌표와 개수를 알 수 있음.

if E1 == E2:
    ###Case 9###
    Result = A_1 * B_1 * math.pi
else:
    if len(Eq_real) == 0:
        ###Case 1###
        if E1.lhs.subs([x, mx_2], [y, my_2]) < 0:#E2의 중점을 E1에 대입했을때, 내부에 있는가?
            Result = A_2 * B_2 * math.pi #E1이 E2를 포함하는 형태 즉 E2의 넓이를 return
        elif E2.lhs.subs([x, mx_1], [y, mx_2]) < 0:#반대
            Result = A_1 * B_1 * math.pi

        ###Case 2###
        else:#포함관계가 없는 경우
            Result = 0

    elif len(Eq_real) == 1:
        ###Case 3###
        if E1.lhs.subs([x, mx_2], [y, my_2]) < 0:    #E2의 중점을 E1에 대입했을때, 내부에 있는가?
            Result = A_2 * B_2 * math.pi   #E1이 E2를 포함하는 형태 즉 E2의 넓이를 return
        elif E2.lhs.subs([x, mx_1], [y, mx_2]) < 0:  #반대
            Result = A_1 * B_1 * math.pi

        ###Case 4###
        else: Result = 0

    elif len(Eq_real) == 2:
        ###Case 5###
        if E1_deriv.subs([x, Eq_real[0][0]], [y, Eq_real[0][1]]) == \
        E1_deriv.subs([x, Eq_real[1][0]], [y, Eq_real[1][1]]):
            Result = min([A_1 * B_1, A_2 * B_2]) * math.pi

        ###Case 6###
        else:
            aφ_1 = angle(Eq_real[0], mx_1, my_1, φ_1)
            aφ_2 = angle(Eq_real[1], mx_1, my_1, φ_1)
            bφ_1 = angle(Eq_real[0], mx_2, my_2, φ_2)
            bφ_2 = angle(Eq_real[1], mx_2, my_2, φ_2)
            Result = min(eseg(aφ_1, aφ_2, A_1, B_1, mx_1, my_1, Eq_real), \
                         eseg(bφ_1, bφ_2, A_2, B_2, mx_2, my_2, Eq_real)) + \
            min(eseg(aφ_2, aφ_1, A_1, B_1, mx_1, my_2, Eq_real), \
                eseg(bφ_2, bφ_1, A_2, B_2, mx_2, my_2, Eq_real))
    elif len(Eq_real) == 3:
        Result = 'none'
        ###CASE 7~###
    
print(Result)